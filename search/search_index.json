{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Exp\u00e9rience avec MkDocs et Pyodide \u2693\ufe0e Ce d\u00e9p\u00f4t est \u00e0 cloner et adapter \u00e0 votre besoin. Cliquer ici pour t\u00e9l\u00e9charger l'archive .zip Pr\u00e9requis \u2693\ufe0e Avec le fichier requirements.txt suivant requirements.txt mkdocs-material mkdocs-macros-plugin mkdocs-awesome-pages-plugin selenium mkdocs-exclude-search V\u00e9rifier l'installation des d\u00e9pendances avec Bash Session $ pip install -r requirements.txt", "title": "\ud83c\udfe1 Accueil"}, {"location": "#experience-avec-mkdocs-et-pyodide", "text": "Ce d\u00e9p\u00f4t est \u00e0 cloner et adapter \u00e0 votre besoin. Cliquer ici pour t\u00e9l\u00e9charger l'archive .zip", "title": "Exp\u00e9rience avec MkDocs et Pyodide"}, {"location": "#prerequis", "text": "Avec le fichier requirements.txt suivant requirements.txt mkdocs-material mkdocs-macros-plugin mkdocs-awesome-pages-plugin selenium mkdocs-exclude-search V\u00e9rifier l'installation des d\u00e9pendances avec Bash Session $ pip install -r requirements.txt", "title": "Pr\u00e9requis"}, {"location": "1-math/", "text": "Maths \u2693\ufe0e On peut \u00e9crire des maths Entr\u00e9e Formule TeX $$ \\sum _{k = 1 }^{ \\infty } \\frac { 1 }{k^ 2 } = \\frac { \\pi ^ 2 }{ 6 } $$ Rendu \\[\\sum_{k=1}^{\\infty} \\frac{1}{k^2} = \\frac{\\pi^2}{6}\\] Pour de plus amples informations, on pourra se r\u00e9f\u00e9rer \u00e0 la page d\u00e9di\u00e9e : https://ens-fr.gitlab.io/mkdocs/maths/", "title": "Maths"}, {"location": "1-math/#maths", "text": "On peut \u00e9crire des maths Entr\u00e9e Formule TeX $$ \\sum _{k = 1 }^{ \\infty } \\frac { 1 }{k^ 2 } = \\frac { \\pi ^ 2 }{ 6 } $$ Rendu \\[\\sum_{k=1}^{\\infty} \\frac{1}{k^2} = \\frac{\\pi^2}{6}\\] Pour de plus amples informations, on pourra se r\u00e9f\u00e9rer \u00e0 la page d\u00e9di\u00e9e : https://ens-fr.gitlab.io/mkdocs/maths/", "title": "Maths"}, {"location": "2-macro/", "text": "Macro \u2693\ufe0e On peut cr\u00e9er sa propre macro Python Dans le fichier main.py , si on ajoute une nouvelle macro comme : \ud83d\udc0d Script Python @env . macro def affiche_addition ( x , y ): texte = [] texte . append ( \"Voici une addition\" ) texte . append ( \"\" ) texte . append ( f \" { x } + { y } = { x + y } \" ) texte . append ( \"\" ) texte . append ( \"Avec LaTeX\" ) texte . append ( \"\" ) texte . append ( f \"$$ { x } + { y } = { x + y } $$\" ) return \" \\n \" . join ( texte ) Il faut alors stopper mkdocs serve puis le relancer ; \u00e0 chaque nouvel ajout de macro. On peut alors l'utiliser Entr\u00e9e {{ affiche_addition(30, 12) }} Rendu Il est d\u00e9licat (mais possible) de l'avoir dans une admonition. Pour commencer, utiliser des macros qui renvoient plusieurs lignes de texte hors admonition et autre cadre avec indentation. Voici une addition 30 + 12 = 42 Avec LaTeX \\[30 + 12 = 42\\] Pour de plus amples informations, se r\u00e9f\u00e9rer \u00e0 la documentation : https://mkdocs-macros-plugin.readthedocs.io/en/latest/", "title": "Macro"}, {"location": "2-macro/#macro", "text": "On peut cr\u00e9er sa propre macro Python Dans le fichier main.py , si on ajoute une nouvelle macro comme : \ud83d\udc0d Script Python @env . macro def affiche_addition ( x , y ): texte = [] texte . append ( \"Voici une addition\" ) texte . append ( \"\" ) texte . append ( f \" { x } + { y } = { x + y } \" ) texte . append ( \"\" ) texte . append ( \"Avec LaTeX\" ) texte . append ( \"\" ) texte . append ( f \"$$ { x } + { y } = { x + y } $$\" ) return \" \\n \" . join ( texte ) Il faut alors stopper mkdocs serve puis le relancer ; \u00e0 chaque nouvel ajout de macro. On peut alors l'utiliser Entr\u00e9e {{ affiche_addition(30, 12) }} Rendu Il est d\u00e9licat (mais possible) de l'avoir dans une admonition. Pour commencer, utiliser des macros qui renvoient plusieurs lignes de texte hors admonition et autre cadre avec indentation. Voici une addition 30 + 12 = 42 Avec LaTeX \\[30 + 12 = 42\\] Pour de plus amples informations, se r\u00e9f\u00e9rer \u00e0 la documentation : https://mkdocs-macros-plugin.readthedocs.io/en/latest/", "title": "Macro"}, {"location": "3-pyodide/", "text": "Pyodide \u2693\ufe0e On peut avoir un IDE avec un fichier Python pr\u00e9charg\u00e9. Avec un fichier exemple.py qui se trouve dans le m\u00eame dossier que votre page.md \u00e0 cr\u00e9er. On ajoute une ligne avec {{ IDE('exemple') }} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder def moyenne(valeurs):bksl-nl return sum(valeurs) / len(valeurs)bksl-nlbksl-nl A Z Pour de plus amples informations, le travail de Vincent Bouillot est pr\u00e9sent\u00e9 ici : https://bouillotvincent.gitlab.io/pyodide-mkdocs/", "title": "Pyodide"}, {"location": "3-pyodide/#pyodide", "text": "On peut avoir un IDE avec un fichier Python pr\u00e9charg\u00e9. Avec un fichier exemple.py qui se trouve dans le m\u00eame dossier que votre page.md \u00e0 cr\u00e9er. On ajoute une ligne avec {{ IDE('exemple') }} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder def moyenne(valeurs):bksl-nl return sum(valeurs) / len(valeurs)bksl-nlbksl-nl A Z Pour de plus amples informations, le travail de Vincent Bouillot est pr\u00e9sent\u00e9 ici : https://bouillotvincent.gitlab.io/pyodide-mkdocs/", "title": "Pyodide"}, {"location": "4-mermaid/", "text": "Mermaid \u2693\ufe0e On peut directement inclure un diagramme Entr\u00e9e Markdown Un _joli_ diagramme ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ``` Rendu Un joli diagramme graph TD; A-->B; A-->C; B-->D; C-->D; Pour de plus amples informations, on pourra consulter le site officiel : < Mermaid >", "title": "Mermaid"}, {"location": "4-mermaid/#mermaid", "text": "On peut directement inclure un diagramme Entr\u00e9e Markdown Un _joli_ diagramme ```mermaid graph TD; A-->B; A-->C; B-->D; C-->D; ``` Rendu Un joli diagramme graph TD; A-->B; A-->C; B-->D; C-->D; Pour de plus amples informations, on pourra consulter le site officiel : < Mermaid >", "title": "Mermaid"}, {"location": "TalNSI/", "text": "Bienvenue sur le site de la classe de Terminale NSI \u2693\ufe0e", "title": "Bienvenue sur le site de la classe de Terminale NSI"}, {"location": "TalNSI/#bienvenue-sur-le-site-de-la-classe-de-terminale-nsi", "text": "", "title": "Bienvenue sur le site de la classe de Terminale NSI"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/", "text": "Un peu d'histoire \u2693\ufe0e La programmation orient\u00e9e objet est un nouveau paradigme de programmation. Les id\u00e9es sous-tendant le paradigme objet datent des ann\u00e9es 60. Mais il faudra attendre le d\u00e9but des ann\u00e9es 70 et la mise au point du langage Smalltalk pour que le paradigme objet gagne en popularit\u00e9 chez les informaticiens. Ajourdh'hui de nombreux langages permettent d'utiliser le paradigme objet : C++, Java, Python... Un petit exemple d'approche : o\u00f9 vous utilisez d\u00e9j\u00e0 des Objets \u2693\ufe0e Prenons une cha\u00eene de caract\u00e8re quelconque : chaine . Completez la ligne ci-dessous pour transformer cette cha\u00eene avec uniquement des minuscules : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder chaine=\"NE CRIE PAS SI FORT\"bksl-nlchainepy-undenpy-undminuscule=.....bksl-nl A Z Vous venez tout juste d'utiliser chaine comme un objet en utilisant la m\u00e9thode lower() . La POO \u2693\ufe0e Vocabulaire \u2693\ufe0e La programmation orient\u00e9e objet repose, comme son nom l'indique, sur le concept d'objet. Un objet dans la vie de tous les jours, vous connaissez, mais en informatique, qu'est ce que c'est ? Une variable ? Une fonction ? Ni l'un ni l'autre, c'est un nouveau concept. Imaginez un objet (de la vie de tous les jours) tr\u00e8s complexe (par exemple un moteur de voiture) : il est \u00e9vident qu'en regardant cet objet, on est frapp\u00e9 par sa complexit\u00e9 (pour un non sp\u00e9cialiste). Imaginez que l'on enferme cet objet dans une caisse et que l'utilisateur de l'objet n'ait pas besoin d'en conna\u00eetre son principe de fonctionnement interne pour pouvoir l'utiliser. L'utilisateur a, \u00e0 sa disposition, des boutons, des manettes et des \u00e9crans de contr\u00f4le pour faire fonctionner l'objet, ce qui rend son utilisation relativement simple. La mise au point de l'objet (par des ing\u00e9nieurs) a \u00e9t\u00e9 tr\u00e8s complexe, en revanche son utilisation est relativement simple. Programmer de mani\u00e8re orient\u00e9e objet, c'est un peu reprendre cette id\u00e9e : utiliser des objets sans se soucier de leur complexit\u00e9 interne. Pour utiliser ces objets, nous n'avons pas \u00e0 notre disposition des boutons, des manettes ou encore des \u00e9crans de contr\u00f4le, mais des attributs et des m\u00e9thodes (nous aurons l'occasion de revenir longuement sur ces 2 concepts). Un des nombreux avantages de la programmation orient\u00e9e objet ( POO ), est qu'il existe des milliers d'objets (on parle plut\u00f4t de classes, mais l\u00e0 aussi nous reviendrons sur ce terme de classe un peu plus loin) pr\u00eats \u00e0 \u00eatre utilis\u00e9s (vous en avez d\u00e9j\u00e0 utilis\u00e9 de nombreuses fois sans le savoir). On peut r\u00e9aliser des programmes extr\u00eamement complexes uniquement en utilisant des classes pr\u00e9existantes. Dans la suite de ce cours, nous utiliserons l'exemple des fractions en math\u00e9matiques. Consid\u00e9rons donc la classe des fractions. La classe est une esp\u00e8ce de \"moule\", \u00e0 partir duquel nous allons cr\u00e9er des objets (plus exactement nous parlerons d' instances ). Par exemple, pour la classe Fractions, nous pouvons cr\u00e9er diff\u00e9rentes instances de cette classe (frac1,frac2...). Pour cr\u00e9er une de ces instances, la proc\u00e9dure est relativement simple : frac1=Fractions(), frac2=Fractions(),... Mais pour le moment, notre classe ne sert \u00e0 rien car il n'y a rien dedans. Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une instance de classe poss\u00e8de des attributs et des m\u00e9thodes. Commen\u00e7ons par les attributs : Un attribut poss\u00e8de une valeur (un peu comme une variable). Nous allons associer un attribut numerateur et un attribut denominateur \u00e0 notre classe Fractions. Ces attributs s'utilisent comme des variables. L'utilisateur va vouloir acc\u00e9der aux diff\u00e9rents attributs de son instance et modifier \u00e9ventuellement ces attributs. Pour cela, on cr\u00e9era deux m\u00e9thodes : get() (pour acc\u00e9der) et set() (pour modifier). Il ne faut pas oublier que notre classe doit \u00eatre \"enferm\u00e9e dans une caisse\" pour que l'utilisateur puisse l'utiliser facilement sans se pr\u00e9occuper de ce qui se passe \u00e0 l'int\u00e9rieur. Il faut donc, \u00e0 la cr\u00e9ation d'une instance, que tous ses attributs soient d\u00e9finis \u00e0 l'aide d'une m\u00e9thode , ici le constructeur __init__ : la m\u00e9thode __init__() est automatiquement ex\u00e9cut\u00e9e au moment de la cr\u00e9ation d'une instance. Il faudra aussi que l'utilisateur puisse faire des op\u00e9rations sur les instances cr\u00e9\u00e9es. Par exemple, il voudra multiplier des fractions, les additionner... toutes ces op\u00e9rations vont \u00eatre d\u00e9finies dans la classe par des m\u00e9thodes : ce sont des fonctions \u00e0 l'int\u00e9rieur de la classe. On aura donc les m\u00e9thodes multiplier() , diviser() , additionner() et soustraire() . L'utilisera voudra enfin afficher les r\u00e9sultats de ses op\u00e9rations, il faudra donc cr\u00e9er une m\u00e9thode pour cela : __str__() qui sera appel\u00e9 lors d'un print(...) . En r\u00e9sum\u00e9 : Une classe est caract\u00e9ris\u00e9e par : un nom (ici Fractions ) des attributs (on parle aussi de champs ou variables d'instances ) (ici numerateur et denominateur ) des m\u00e9thodes : ce sont des fonctions de traitement de donn\u00e9es de la classe. Parmis celles-ci, on retrouve : le constructeur : elle initialise les donn\u00e9es de la classe \u00e0 leur cr\u00e9ation les accesseurs : en lecture : elle se contente de renvoyer la valeur d'une variable d'instance. (ici get() ) en \u00e9criture : elle se contente de modifier la valeur d'une variable d'instance, avec \u00e9ventuellement une v\u00e9rification de la nouvelle valeur. (ici set() ) les autres : ce sont des fonctions de traitement de donn\u00e9es de la classe. (ici multiplier() ,...) Mod\u00e8le UML \u2693\ufe0e Nous pouvons r\u00e9sumer l'ensemble de ce qui a \u00e9t\u00e9 dit dans un sch\u00e9ma appel\u00e9 diagramme de classe (mod\u00e8le UML). Pour notre classe Fractions, cela donnera : Mise en pratique avec Python \u2693\ufe0e Ouvrez le notebook : fractions.ipynb et faites le TP. Exercices \u2693\ufe0e Exercice 1 On consid\u00e8re le code suivant : \ud83d\udc0d Script Python class Personne : def __init__ ( self , nom , age ): self . set_nom ( nom ) self . set_age ( age ) def set_nom ( self , nouveau_nom ): self . nom = nouveau_nom def set_age ( self , nouvel_age ): self . age = nouvel_age def get_nom ( self ): return self . nom def get_age ( self ): return self . age def Vieillir ( self , periode ): self . set_age ( self . get_age () + periode ) return f \"le nouvel age de { self . get_nom () } est : { str ( self . get_age ()) } \" Moi = Personne ( \"Albert\" , 51 ) Monchien = Personne ( \"Rex\" , 14 ) for i in range ( 3 ): Moi . Vieillir ( 1 ) Monchien . Vieillir ( 7 ) 1) Quels sont les noms des attributs d\u2019un objet de la classe Personne ? 2) Que fait la m\u00e9thode Vieillir ? 3) A la \ufb01n de la boucle, on execute \u00e0 la console : \ud83d\udc0d Script Python Moi . age Quel est l'affichage? 4) Quel est l'\u00e2ge de Rex apr\u00e8s l'ex\u00e9cution du programme, comment l'obtenir? Exercice 2 A l\u2019aide du code Python ci-dessous, r\u00e9pondre aux questions suivantes : 1) Quels sont les noms des attributs de R1 et R2 ? 2) Compl\u00e9ter la m\u00e9thode afficher_aire() permettant de calculer l\u2019aire d\u2019un rectangle. 3) Compl\u00e9ter les lignes de commandes \u00e0 la console pour a\ufb03cher les aires et p\u00e9rim\u00e8tres de R1 et R2. \ud83d\udc0d Script Python class Rectangle : def __init__ ( self , longueur , largeur ): self . set_longueur ( longueur ) self . set_largeur ( largeur ) def get_largeur ( self ): return self . largeur def get_longueur ( self ): return self . longueur def set_longueur ( self , nouvel_longueur ): self . longueur = nouvel_longueur def set_largeur ( self , nouvel_largeur ): self . largeur = nouvel_largeur def afficher_perimetre ( self ): p = 2 * ( self . get_largeur () + self . get_longueur ()) return f \"le perimetre du rectangle est : { str ( p ) } \" def afficher_aire ( self ): R1 = Rectangle ( 4 , 3 ) R2 = Rectangle ( 5 , 6 ) \ud83d\udc0d Script Python >>> >>> >>> Exercice 3 Les loueurs de voitures doivent g\u00e9rer l\u2019entretien des voitures de location. En principe il faut e\ufb00ectuer une r\u00e9vision tous les 20 000 km. (Quand on a d\u00e9pass\u00e9 les 20 000 km puis les 40 000 km, ...) On suppose \u00e9crite la classe \u00ab vehicule \u00bb, dont on vous donne les en-t\u00eates de m\u00e9thodes : \ud83d\udc0d Script Python class Vehicule : def __init__ ( self , marque , modele , km , nbRevisions ): self . set_marque ( marque ) self . set_modele ( modele ) self . set_km ( km ) self . set_nbRevisions ( nbRevisions ) def get_marque ( self ): return self . marque def get_modele ( self ): return self . modele def get_km ( self ): return self . km def get_nbRevisions ( self ): return self . nbRevisions def set_marque ( self , nouvel_marque ): self . marque = nouvel_marque def set_modele ( self , nouveau_modele ): self . modele = nouveau_modele def set_km ( self , nouveau_km ): self . km = nouveau_km def set_nbRevisions ( self , nouvel_nbRevisions ): self . nbRevisions = nouvel_nbRevisions def bilan ( self ): def faire_revision ( self ): def ajouter_km ( self , km_parcourus ): 1) Cr\u00e9er les trois v\u00e9hicules suivants : Voiture1 : une Peugeot 107 toute neuve Voiture2 : une Peugeot 207 de 15 000 km Voiture3 : une Peugeot 307 de 26 000 km ayant d\u00e9j\u00e0 e\ufb00ectu\u00e9 une r\u00e9vision 2) Compl\u00e9ter la m\u00e9thode \u00ab bilan \u00bb permettant d\u2019a\ufb03cher la marque, le mod\u00e8le de la voiture, le nombre de km, ainsi que le nombre de r\u00e9visions d\u00e9j\u00e0 e\ufb00ectu\u00e9es. 3) Compl\u00e9ter la m\u00e9thode \u00ab faire_revision \u00bb de mani\u00e8re \u00e0 incr\u00e9menter l\u2019attribut correspondant au nombre de r\u00e9visions. 4) A chaque retour d\u2019une voiture le loueur ajoute \u00e0 la voiture le nombre de kilom\u00e8tres e\ufb00ectu\u00e9s.\\ Compl\u00e9ter la m\u00e9thode \u00ab ajouter_km \u00bb permettant d\u2019ajouter \u00e0 la voiture le nombre de kilom\u00e8tres parcourus.\\ En fonction du nombre de kilom\u00e8tres total de la voiture, la m\u00e9thode \u00ab ajouter_km \u00bb devra appeler la m\u00e9thode \u00ab faire_revision \u00bb.\\ Exemple 1 : La voiture a 15 000 km, elle a parcouru 4 000 km soit un total de 19 000 km. La m\u00e9thode doit uniquement ajouter les kilom\u00e8tres.\\ Exemple 2 : La voiture a 15 000 km, elle a parcouru 6 000 km soit un total de 21 000 km. La m\u00e9thode doit ajouter les kilom\u00e8tres et pr\u00e9ciser que la r\u00e9vision doit \u00eatre faite si elle n\u2019a pas d\u00e9j\u00e0 e\ufb00ectu\u00e9e.\\ Exemple 3 : La voiture a 21 000 km, elle a parcouru 4 000 km soit un total de 25 000 km. La voiture a d\u00e9j\u00e0 effectu\u00e9 la r\u00e9vision 1, la m\u00e9thode doit uniquement ajouter les kilom\u00e8tres. Exercice 4 1) D\u00e9finir une classe Livre avec les attributs suivants : Titre, Auteur (Nom complet), Prix. 2) D\u00e9finir \u00e0 l\u2019aide des propri\u00e9t\u00e9s les m\u00e9thodes d\u2019acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d\u2019initialiser les attributs de la m\u00e9thode par des valeurs saisies par l\u2019utilisateur. 4) D\u00e9finir la m\u00e9thode __str__() permettant d\u2019afficher les informations du livre en cours. 5) \u00c9crire un programme testant la classe Livre. 6) Faire le diagramme de classe correspondant. Exercice 5 1) D\u00e9finir une classe Point avec les attributs : Abscisse et Ordonn\u00e9e. 2) D\u00e9finir \u00e0 l'aide des propri\u00e9t\u00e9s les m\u00e9thodes d'acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d'initialiser les attributs de la m\u00e9thode par des valeurs saisies par l'utilisateur. 4) D\u00e9finir la m\u00e9thode __str__() permettant d'afficher les coordonn\u00e9es du point en cours. 5) D\u00e9finir la m\u00e9thode distance() permettant de calculer la distance entre deux points. 6) Ecrire un programme testant la classe Point. 7) D\u00e9finir de la m\u00eame mani\u00e8re une classe Segment, avec pour m\u00e9thode longueur() (pour la longueur d'un segment) et milieu() (pour les coordonn\u00e9es du milieu du segment). 8) Faire les diagrammes de classe correspondants. Exercice 6 1) D\u00e9finir une classe Employ\u00e9 caract\u00e9ris\u00e9e par les attributs : Matricule, Nom, Pr\u00e9nom, DateNaissance, DateEmbauche, Salaire. 2) D\u00e9finir \u00e0 l\u2019aide des propri\u00e9t\u00e9s les m\u00e9thodes d\u2019acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d\u2019initialiser les attributs de la m\u00e9thode par des valeurs saisies par l\u2019utilisateur. 4) Ajouter \u00e0 la classe la m\u00e9thode Age() qui retourne l\u2019\u00e2ge de l\u2019employ\u00e9. 5) Ajouter \u00e0 la classe la m\u00e9thode Anciennete() qui retourne le nombre d\u2019ann\u00e9es d\u2019anciennet\u00e9 de l\u2019employ\u00e9. 6) Ajouter \u00e0 la classe la m\u00e9thode AugmentationDuSalaire() qui augmente le salaire de l\u2019employ\u00e9 en prenant en consid\u00e9ration l\u2019anciennet\u00e9.\\ - Si Anciennet\u00e9 < 5 ans, alors on ajoute 2%. - Si Anciennet\u00e9 < 10 ans, alors on ajoute 5%. - Sinon, on ajoute 10%. 7) Ajouter la m\u00e9thode __str__() qui affiche les informations de l\u2019employ\u00e9 comme suit :\\ Matricule : [\u2026]\\ Nom complet : [NOM Pr\u00e9nom]\\ Age : [\u2026]\\ Anciennet\u00e9 : [\u2026]\\ Salaire : [\u2026]\\ Le nom doit \u00eatre affich\u00e9 en majuscule. Pour le pr\u00e9nom, la premi\u00e8re lettre doit \u00eatre en majuscule, les autres en minuscule. 8) Faire le diagramme de classe correspondant.", "title": "La Programmation Orient\u00e9e Objet"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#un-peu-dhistoire", "text": "La programmation orient\u00e9e objet est un nouveau paradigme de programmation. Les id\u00e9es sous-tendant le paradigme objet datent des ann\u00e9es 60. Mais il faudra attendre le d\u00e9but des ann\u00e9es 70 et la mise au point du langage Smalltalk pour que le paradigme objet gagne en popularit\u00e9 chez les informaticiens. Ajourdh'hui de nombreux langages permettent d'utiliser le paradigme objet : C++, Java, Python...", "title": "Un peu d'histoire"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#un-petit-exemple-dapproche-ou-vous-utilisez-deja-des-objets", "text": "Prenons une cha\u00eene de caract\u00e8re quelconque : chaine . Completez la ligne ci-dessous pour transformer cette cha\u00eene avec uniquement des minuscules : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder chaine=\"NE CRIE PAS SI FORT\"bksl-nlchainepy-undenpy-undminuscule=.....bksl-nl A Z Vous venez tout juste d'utiliser chaine comme un objet en utilisant la m\u00e9thode lower() .", "title": "Un petit exemple d'approche : o\u00f9 vous utilisez d\u00e9j\u00e0 des Objets"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#la-poo", "text": "", "title": "La POO"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#vocabulaire", "text": "La programmation orient\u00e9e objet repose, comme son nom l'indique, sur le concept d'objet. Un objet dans la vie de tous les jours, vous connaissez, mais en informatique, qu'est ce que c'est ? Une variable ? Une fonction ? Ni l'un ni l'autre, c'est un nouveau concept. Imaginez un objet (de la vie de tous les jours) tr\u00e8s complexe (par exemple un moteur de voiture) : il est \u00e9vident qu'en regardant cet objet, on est frapp\u00e9 par sa complexit\u00e9 (pour un non sp\u00e9cialiste). Imaginez que l'on enferme cet objet dans une caisse et que l'utilisateur de l'objet n'ait pas besoin d'en conna\u00eetre son principe de fonctionnement interne pour pouvoir l'utiliser. L'utilisateur a, \u00e0 sa disposition, des boutons, des manettes et des \u00e9crans de contr\u00f4le pour faire fonctionner l'objet, ce qui rend son utilisation relativement simple. La mise au point de l'objet (par des ing\u00e9nieurs) a \u00e9t\u00e9 tr\u00e8s complexe, en revanche son utilisation est relativement simple. Programmer de mani\u00e8re orient\u00e9e objet, c'est un peu reprendre cette id\u00e9e : utiliser des objets sans se soucier de leur complexit\u00e9 interne. Pour utiliser ces objets, nous n'avons pas \u00e0 notre disposition des boutons, des manettes ou encore des \u00e9crans de contr\u00f4le, mais des attributs et des m\u00e9thodes (nous aurons l'occasion de revenir longuement sur ces 2 concepts). Un des nombreux avantages de la programmation orient\u00e9e objet ( POO ), est qu'il existe des milliers d'objets (on parle plut\u00f4t de classes, mais l\u00e0 aussi nous reviendrons sur ce terme de classe un peu plus loin) pr\u00eats \u00e0 \u00eatre utilis\u00e9s (vous en avez d\u00e9j\u00e0 utilis\u00e9 de nombreuses fois sans le savoir). On peut r\u00e9aliser des programmes extr\u00eamement complexes uniquement en utilisant des classes pr\u00e9existantes. Dans la suite de ce cours, nous utiliserons l'exemple des fractions en math\u00e9matiques. Consid\u00e9rons donc la classe des fractions. La classe est une esp\u00e8ce de \"moule\", \u00e0 partir duquel nous allons cr\u00e9er des objets (plus exactement nous parlerons d' instances ). Par exemple, pour la classe Fractions, nous pouvons cr\u00e9er diff\u00e9rentes instances de cette classe (frac1,frac2...). Pour cr\u00e9er une de ces instances, la proc\u00e9dure est relativement simple : frac1=Fractions(), frac2=Fractions(),... Mais pour le moment, notre classe ne sert \u00e0 rien car il n'y a rien dedans. Comme expliqu\u00e9 pr\u00e9c\u00e9demment, une instance de classe poss\u00e8de des attributs et des m\u00e9thodes. Commen\u00e7ons par les attributs : Un attribut poss\u00e8de une valeur (un peu comme une variable). Nous allons associer un attribut numerateur et un attribut denominateur \u00e0 notre classe Fractions. Ces attributs s'utilisent comme des variables. L'utilisateur va vouloir acc\u00e9der aux diff\u00e9rents attributs de son instance et modifier \u00e9ventuellement ces attributs. Pour cela, on cr\u00e9era deux m\u00e9thodes : get() (pour acc\u00e9der) et set() (pour modifier). Il ne faut pas oublier que notre classe doit \u00eatre \"enferm\u00e9e dans une caisse\" pour que l'utilisateur puisse l'utiliser facilement sans se pr\u00e9occuper de ce qui se passe \u00e0 l'int\u00e9rieur. Il faut donc, \u00e0 la cr\u00e9ation d'une instance, que tous ses attributs soient d\u00e9finis \u00e0 l'aide d'une m\u00e9thode , ici le constructeur __init__ : la m\u00e9thode __init__() est automatiquement ex\u00e9cut\u00e9e au moment de la cr\u00e9ation d'une instance. Il faudra aussi que l'utilisateur puisse faire des op\u00e9rations sur les instances cr\u00e9\u00e9es. Par exemple, il voudra multiplier des fractions, les additionner... toutes ces op\u00e9rations vont \u00eatre d\u00e9finies dans la classe par des m\u00e9thodes : ce sont des fonctions \u00e0 l'int\u00e9rieur de la classe. On aura donc les m\u00e9thodes multiplier() , diviser() , additionner() et soustraire() . L'utilisera voudra enfin afficher les r\u00e9sultats de ses op\u00e9rations, il faudra donc cr\u00e9er une m\u00e9thode pour cela : __str__() qui sera appel\u00e9 lors d'un print(...) . En r\u00e9sum\u00e9 : Une classe est caract\u00e9ris\u00e9e par : un nom (ici Fractions ) des attributs (on parle aussi de champs ou variables d'instances ) (ici numerateur et denominateur ) des m\u00e9thodes : ce sont des fonctions de traitement de donn\u00e9es de la classe. Parmis celles-ci, on retrouve : le constructeur : elle initialise les donn\u00e9es de la classe \u00e0 leur cr\u00e9ation les accesseurs : en lecture : elle se contente de renvoyer la valeur d'une variable d'instance. (ici get() ) en \u00e9criture : elle se contente de modifier la valeur d'une variable d'instance, avec \u00e9ventuellement une v\u00e9rification de la nouvelle valeur. (ici set() ) les autres : ce sont des fonctions de traitement de donn\u00e9es de la classe. (ici multiplier() ,...)", "title": "Vocabulaire"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#modele-uml", "text": "Nous pouvons r\u00e9sumer l'ensemble de ce qui a \u00e9t\u00e9 dit dans un sch\u00e9ma appel\u00e9 diagramme de classe (mod\u00e8le UML). Pour notre classe Fractions, cela donnera :", "title": "Mod\u00e8le UML"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#mise-en-pratique-avec-python", "text": "Ouvrez le notebook : fractions.ipynb et faites le TP.", "title": "Mise en pratique avec Python"}, {"location": "TalNSI/02-Programmation_Orientee_Objet/Programmation_Orientee_Objet/#exercices", "text": "Exercice 1 On consid\u00e8re le code suivant : \ud83d\udc0d Script Python class Personne : def __init__ ( self , nom , age ): self . set_nom ( nom ) self . set_age ( age ) def set_nom ( self , nouveau_nom ): self . nom = nouveau_nom def set_age ( self , nouvel_age ): self . age = nouvel_age def get_nom ( self ): return self . nom def get_age ( self ): return self . age def Vieillir ( self , periode ): self . set_age ( self . get_age () + periode ) return f \"le nouvel age de { self . get_nom () } est : { str ( self . get_age ()) } \" Moi = Personne ( \"Albert\" , 51 ) Monchien = Personne ( \"Rex\" , 14 ) for i in range ( 3 ): Moi . Vieillir ( 1 ) Monchien . Vieillir ( 7 ) 1) Quels sont les noms des attributs d\u2019un objet de la classe Personne ? 2) Que fait la m\u00e9thode Vieillir ? 3) A la \ufb01n de la boucle, on execute \u00e0 la console : \ud83d\udc0d Script Python Moi . age Quel est l'affichage? 4) Quel est l'\u00e2ge de Rex apr\u00e8s l'ex\u00e9cution du programme, comment l'obtenir? Exercice 2 A l\u2019aide du code Python ci-dessous, r\u00e9pondre aux questions suivantes : 1) Quels sont les noms des attributs de R1 et R2 ? 2) Compl\u00e9ter la m\u00e9thode afficher_aire() permettant de calculer l\u2019aire d\u2019un rectangle. 3) Compl\u00e9ter les lignes de commandes \u00e0 la console pour a\ufb03cher les aires et p\u00e9rim\u00e8tres de R1 et R2. \ud83d\udc0d Script Python class Rectangle : def __init__ ( self , longueur , largeur ): self . set_longueur ( longueur ) self . set_largeur ( largeur ) def get_largeur ( self ): return self . largeur def get_longueur ( self ): return self . longueur def set_longueur ( self , nouvel_longueur ): self . longueur = nouvel_longueur def set_largeur ( self , nouvel_largeur ): self . largeur = nouvel_largeur def afficher_perimetre ( self ): p = 2 * ( self . get_largeur () + self . get_longueur ()) return f \"le perimetre du rectangle est : { str ( p ) } \" def afficher_aire ( self ): R1 = Rectangle ( 4 , 3 ) R2 = Rectangle ( 5 , 6 ) \ud83d\udc0d Script Python >>> >>> >>> Exercice 3 Les loueurs de voitures doivent g\u00e9rer l\u2019entretien des voitures de location. En principe il faut e\ufb00ectuer une r\u00e9vision tous les 20 000 km. (Quand on a d\u00e9pass\u00e9 les 20 000 km puis les 40 000 km, ...) On suppose \u00e9crite la classe \u00ab vehicule \u00bb, dont on vous donne les en-t\u00eates de m\u00e9thodes : \ud83d\udc0d Script Python class Vehicule : def __init__ ( self , marque , modele , km , nbRevisions ): self . set_marque ( marque ) self . set_modele ( modele ) self . set_km ( km ) self . set_nbRevisions ( nbRevisions ) def get_marque ( self ): return self . marque def get_modele ( self ): return self . modele def get_km ( self ): return self . km def get_nbRevisions ( self ): return self . nbRevisions def set_marque ( self , nouvel_marque ): self . marque = nouvel_marque def set_modele ( self , nouveau_modele ): self . modele = nouveau_modele def set_km ( self , nouveau_km ): self . km = nouveau_km def set_nbRevisions ( self , nouvel_nbRevisions ): self . nbRevisions = nouvel_nbRevisions def bilan ( self ): def faire_revision ( self ): def ajouter_km ( self , km_parcourus ): 1) Cr\u00e9er les trois v\u00e9hicules suivants : Voiture1 : une Peugeot 107 toute neuve Voiture2 : une Peugeot 207 de 15 000 km Voiture3 : une Peugeot 307 de 26 000 km ayant d\u00e9j\u00e0 e\ufb00ectu\u00e9 une r\u00e9vision 2) Compl\u00e9ter la m\u00e9thode \u00ab bilan \u00bb permettant d\u2019a\ufb03cher la marque, le mod\u00e8le de la voiture, le nombre de km, ainsi que le nombre de r\u00e9visions d\u00e9j\u00e0 e\ufb00ectu\u00e9es. 3) Compl\u00e9ter la m\u00e9thode \u00ab faire_revision \u00bb de mani\u00e8re \u00e0 incr\u00e9menter l\u2019attribut correspondant au nombre de r\u00e9visions. 4) A chaque retour d\u2019une voiture le loueur ajoute \u00e0 la voiture le nombre de kilom\u00e8tres e\ufb00ectu\u00e9s.\\ Compl\u00e9ter la m\u00e9thode \u00ab ajouter_km \u00bb permettant d\u2019ajouter \u00e0 la voiture le nombre de kilom\u00e8tres parcourus.\\ En fonction du nombre de kilom\u00e8tres total de la voiture, la m\u00e9thode \u00ab ajouter_km \u00bb devra appeler la m\u00e9thode \u00ab faire_revision \u00bb.\\ Exemple 1 : La voiture a 15 000 km, elle a parcouru 4 000 km soit un total de 19 000 km. La m\u00e9thode doit uniquement ajouter les kilom\u00e8tres.\\ Exemple 2 : La voiture a 15 000 km, elle a parcouru 6 000 km soit un total de 21 000 km. La m\u00e9thode doit ajouter les kilom\u00e8tres et pr\u00e9ciser que la r\u00e9vision doit \u00eatre faite si elle n\u2019a pas d\u00e9j\u00e0 e\ufb00ectu\u00e9e.\\ Exemple 3 : La voiture a 21 000 km, elle a parcouru 4 000 km soit un total de 25 000 km. La voiture a d\u00e9j\u00e0 effectu\u00e9 la r\u00e9vision 1, la m\u00e9thode doit uniquement ajouter les kilom\u00e8tres. Exercice 4 1) D\u00e9finir une classe Livre avec les attributs suivants : Titre, Auteur (Nom complet), Prix. 2) D\u00e9finir \u00e0 l\u2019aide des propri\u00e9t\u00e9s les m\u00e9thodes d\u2019acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d\u2019initialiser les attributs de la m\u00e9thode par des valeurs saisies par l\u2019utilisateur. 4) D\u00e9finir la m\u00e9thode __str__() permettant d\u2019afficher les informations du livre en cours. 5) \u00c9crire un programme testant la classe Livre. 6) Faire le diagramme de classe correspondant. Exercice 5 1) D\u00e9finir une classe Point avec les attributs : Abscisse et Ordonn\u00e9e. 2) D\u00e9finir \u00e0 l'aide des propri\u00e9t\u00e9s les m\u00e9thodes d'acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d'initialiser les attributs de la m\u00e9thode par des valeurs saisies par l'utilisateur. 4) D\u00e9finir la m\u00e9thode __str__() permettant d'afficher les coordonn\u00e9es du point en cours. 5) D\u00e9finir la m\u00e9thode distance() permettant de calculer la distance entre deux points. 6) Ecrire un programme testant la classe Point. 7) D\u00e9finir de la m\u00eame mani\u00e8re une classe Segment, avec pour m\u00e9thode longueur() (pour la longueur d'un segment) et milieu() (pour les coordonn\u00e9es du milieu du segment). 8) Faire les diagrammes de classe correspondants. Exercice 6 1) D\u00e9finir une classe Employ\u00e9 caract\u00e9ris\u00e9e par les attributs : Matricule, Nom, Pr\u00e9nom, DateNaissance, DateEmbauche, Salaire. 2) D\u00e9finir \u00e0 l\u2019aide des propri\u00e9t\u00e9s les m\u00e9thodes d\u2019acc\u00e8s aux diff\u00e9rents attributs de la classe. 3) D\u00e9finir un constructeur permettant d\u2019initialiser les attributs de la m\u00e9thode par des valeurs saisies par l\u2019utilisateur. 4) Ajouter \u00e0 la classe la m\u00e9thode Age() qui retourne l\u2019\u00e2ge de l\u2019employ\u00e9. 5) Ajouter \u00e0 la classe la m\u00e9thode Anciennete() qui retourne le nombre d\u2019ann\u00e9es d\u2019anciennet\u00e9 de l\u2019employ\u00e9. 6) Ajouter \u00e0 la classe la m\u00e9thode AugmentationDuSalaire() qui augmente le salaire de l\u2019employ\u00e9 en prenant en consid\u00e9ration l\u2019anciennet\u00e9.\\ - Si Anciennet\u00e9 < 5 ans, alors on ajoute 2%. - Si Anciennet\u00e9 < 10 ans, alors on ajoute 5%. - Sinon, on ajoute 10%. 7) Ajouter la m\u00e9thode __str__() qui affiche les informations de l\u2019employ\u00e9 comme suit :\\ Matricule : [\u2026]\\ Nom complet : [NOM Pr\u00e9nom]\\ Age : [\u2026]\\ Anciennet\u00e9 : [\u2026]\\ Salaire : [\u2026]\\ Le nom doit \u00eatre affich\u00e9 en majuscule. Pour le pr\u00e9nom, la premi\u00e8re lettre doit \u00eatre en majuscule, les autres en minuscule. 8) Faire le diagramme de classe correspondant.", "title": "Exercices"}, {"location": "toto/chap2/ch2/", "text": "Test \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder # Toto est dans la placebksl-nl A Z", "title": "Ch2"}, {"location": "toto/chap2/ch2/#test", "text": "Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser Recharger Sauvegarder # Toto est dans la placebksl-nl A Z", "title": "Test"}]}